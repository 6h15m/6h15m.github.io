{
    "componentChunkName": "component---src-pages-index-tsx",
    "path": "/",
    "result": {"data":{"site":{"siteMetadata":{"title":"영의 시간"}},"allMarkdownRemark":{"group":[{"fieldValue":"Github","totalCount":1},{"fieldValue":"Jekyll","totalCount":2},{"fieldValue":"Reactive Programming","totalCount":5},{"fieldValue":"RxJS","totalCount":5}],"nodes":[{"fields":{"slug":"/rxjs-subscription/"},"frontmatter":{"date":"2022.04.14","update":"2022.04.14","title":"[번역] RxJS 공식 문서 #Subscription","tags":["RxJS","Reactive Programming"],"description":"🇰🇷 구독과 좋아요, 알림 설정까지-"},"rawMarkdownBody":"  \n## 프롤로그\n\n안녕하세요! 제로입니다.\n이번에 번역해본 문서는 [Subscription](https://rxjs.dev/guide/subscription) 입니다. \n옵저버블과 연산자 등에 대해서 공부해보았으니, 직접적으로 실행하는 부분인 구독도 자세히 알아볼까요?\n\n## Subscription(구독) 소개\n\n**구독**은 일회성 리소스 객체로, RxJS에서는 옵저버블의 실행을 나타냅니다.\n구독에는 매우 중요한 메소드인 `unsubscribe`가 존재합니다.\n이 메소드는 구독에서 사용되고 있는 리소스를 해제합니다.\nRxJS의 예전 버전들에서 구독의 이름은 \"Disposable(일회성)\"이었습니다.\n\n```ts\nimport { interval } from \"rxjs\";\nconst observable = interval(1000);\nconst subscription = observable.subscribe((x) => console.log(x));\n// 밑의 코드는 옵저버의 구독 호출로 시작된,\n// 현재까지 진행 중인 옵저버블 실행을 취소합니다.\nsubscription.unsubscribe();\n```\n\n> 구독에는 리소스를 해제하거나 옵저버블 실행을 취소하는 `unsubscribe()` 함수가 있습니다.\n\n한 구독에서 `unsubscribe()`를 호출해 여러 구독을 취소하고 싶다면,\n하나의 구독을 다른 구독에 \"추가\"하기만 하면 되죠.\n\n```ts\nimport { interval } from \"rxjs\";\nconst observable1 = interval(400);\nconst observable2 = interval(300);\nconst subscription = observable1.subscribe((x) => console.log(\"첫 번째: \" + x));\nconst childSubscription = observable2.subscribe((x) =>\n  console.log(\"두 번째: \" + x),\n);\nsubscription.add(childSubscription);\nsetTimeout(() => {\n  // subscription과 childSubscription 모두 구독 취소\n  subscription.unsubscribe();\n}, 1000);\n```\n\n콘솔에서 실행 결과를 확인해볼까요?\n\n```none\n두 번째: 0\n첫 번째: 0\n두 번째: 1\n첫 번째: 1\n두 번째: 2\n```\n\n구독 객체는 하위 구독의 추가를 취소하기 위한 `remove(otherSubscription)` 메소드도 갖고 있습니다.\n"},{"fields":{"slug":"/rxjs-operators/"},"frontmatter":{"date":"2022.04.13","update":"2022.04.13","title":"[번역] RxJS 공식 문서 #Operators","tags":["RxJS","Reactive Programming"],"description":"🇰🇷 Operator, 너는 진짜 누구냐-"},"rawMarkdownBody":"\n## 프롤로그\n\n안녕하세요! 제로입니다.\n저번의 [RxJS 공식 문서 번역 #Observer](https://6h15m.github.io/rxjs-observer/) 에 이어,\n공식 문서 가이드의 [Operators](https://rxjs.dev/guide/operators) 문서를 번역해보려 합니다.\n\n## RxJS Operator(연산자) 소개\n\nRxJS는 _연산자_ 덕분에 유용합니다. 옵저버블 기반인데도 말이죠.\n연산자는 복잡한 비동기 코드를 쉽게 선언적으로 구성할 수 있도록 해주는 필수적 요소입니다.\n\n## 연산자란?\n\n연산자는 **함수**입니다. RxJS에는 두 종류의 연산자들이 존재하는데요,\n\n**파이프형 연산자**는 `observableInstance.pipe(operator())` 구문을 사용해 옵저버블에 연결할 수 있는 연산자들입니다.\n[`filter(...)`](https://rxjs.dev/api/operators/filter) 나 [`mergeMap(...)`](https://rxjs.dev/api/operators/mergeMap) 같은 것들이 포함되죠.\n이 연산자들을 호출해도 기존의 옵저버블 인스턴스는 _변경되지 않습니다_.\n대신, 첫 번째 옵저버블을 기반으로 _새로운_ 옵저버블을 리턴합니다.\n\n> 파이프형 연산자는 옵저버블을 입력 값처럼 사용하고 다른 옵저버블을 리턴하는 함수입니다. 이 연산자는 순수함수로, 이전 옵저버블은 수정되지 않은 채로 유지됩니다.\n\n파이프형 연산자는 기본적으로 하나의 옵저버블을 입력 값으로 사용하며, 다른 옵저버블을 출력 값으로 생성하는 순수함수입니다.\n출력 옵저버블을 구독하면 입력 옵저버블도 구독됩니다.\n\n**생성 연산자**는 새로운 옵저버블을 생성하기 위한 독립형 함수입니다.\n예를 들어, `of(1, 2, 3)`은 1, 2, 3을 차례대로 방출하는 옵저버블을 생성합니다.\n생성 연산자에 대해서는 뒷부분에서 더 자세히 다뤄보겠습니다.\n\n[`map`](https://rxjs.dev/api/operators/map) 이라고 하는 연산자를 함께 보겠습니다.\n이 연산자는 동일한 이름의 Array 메소드와 유사하죠.\n`[1, 2, 3].map(x => x * x)`이 `[1, 4, 9]`를 생성하듯이, 옵저버블은 다음과 같이 생성됩니다.\n\n```ts\nimport { of, map } from \"rxjs\";\nof(1, 2, 3)\n  .pipe(map((x) => x * x))\n  .subscribe((v) => console.log(`값: ${v}`));\n// 로그:\n// 값: 1\n// 값: 4\n// 값: 9\n```\n\n`1`, `4`, `9`를 방출하죠. 다른 유용한 연산자인 [`first`](https://rxjs.dev/api/operators/first)도 소개해 드리겠습니다.\n\n```ts\nimport { of, first } from \"rxjs\";\nof(1, 2, 3)\n  .pipe(first())\n  .subscribe((v) => console.log(`값: ${v}`));\n// 로그:\n// 값: 1\n```\n\n논리적으로 생각해 보면, `map`은 매핑 기능을 제공해야 하므로 즉시 생성되어야 합니다.\n그러나 `first`는 상수가 될 수 있음에도 불구하고 똑같이 즉시 생성되죠.\n일반적으로 모든 연산자는 인수 필요 여부에 관계없이 구성되어 있습니다.\n\n## 파이핑\n\n파이프형 연산자들은 함수이기 때문에, 일반 함수들처럼 사용할 _수_ 있습니다.\n\n`op()(obs)`\n\n그러나, 많은 양의 함수들이 합성되면 가독성이 떨어지게 됩니다. 이렇게요.\n\n`op4()(op3()(op2()(op1()(obs))))`\n\n이러한 이유로 옵저버블은 `.pipe()` 메소드를 사용해 동일한 작업을 수행하되, 가독성까지 챙겼죠.\n\n```ts\nobs.pipe(op1(), op2(), op3(), op4());\n```\n\n하나의 연산자만 사용하더라도 `op()(obs)` 형태로는 사용되지 않고, `obs.pipe(op())` 형태가 주로 선호됩니다.\n\n## 생성 연산자\n\n**생성 연산자**는 파이프형 연산자와 달리, 몇 가지 사전 정의된 동작을 이용하거나 다른 옵저버블과 결합함으로써 옵저버블을 생성할 수 있는 함수입니다.\n\n생성 연산자의 대표적인 예시는 `interval` 함수입니다.\n입력 인수로 (옵저버블이 아닌) 숫자를 받고, 출력으로 옵저버블을 생성합니다.\n\n```ts\nimport { interval } from \"rxjs\";\nconst observable = interval(1000 /* 밀리초 */);\n```\n\n[여기](#생성-연산자) 에 모든 정적 생성 연산자들을 참조해두었습니다.\n\n## 고차원 옵저버블\n\n옵저버블은 보통 문자열이나 숫자 같은 일반적인 값들을 방출하지만, 가끔 옵저버블 _의_ 옵저버블, 소위 고차원 옵저버블을 다뤄야 할 때가 있습니다.\n예를 들어, 파일의 URL로 구성된 문자열 옵저버블이 있다고 가정해 봅시다.\n\n```ts\nconst fileObservable = urlObservable.pipe(map((url) => http.get(url)));\n```\n\n`http.get()`은 개별 URL에 대해 (문자열 또는 문자열 배열) 옵저버블을 리턴합니다.\n이제 옵저버블 _의_ 옵저버블, 고차원 옵저버블이 준비되었습니다.\n\n고차원 옵저버블을 다루려면 어떻게 해야 할까요?\n일반적으로는, _flattening(평탄화 작업)_ 을 거쳐 고차원 옵저버블을 일반 옵저버블로 변환합니다.\n\n```ts\nconst fileObservable = urlObservable.pipe(\n  map((url) => http.get(url)),\n  concatAll(),\n);\n```\n\n[`concatAll()`](https://rxjs.dev/api/operators/concatAll) 연산자는 \"외부\" 옵저버블에서 방출되는 \"내부\" 옵저버블을 구독하고,\n해당 옵저버블이 완료될 때까지 방출된 모든 값을 복사해 다음 옵저버블로 이동합니다.\n모든 값이 이런 방식으로 연결되어 있죠.\n유용한 평탄화 연산자([결합 연산자](#결합-연산자))에는,\n\n- [`mergeAll()`](https://rxjs.dev/api/operators/mergeAll) — 내부 옵저버블이 도착할 때 구독해서, 다음 값이 도착할 때 방출합니다.\n- [`switchAll()`](https://rxjs.dev/api/operators/switchAll) — 첫 번째 내부 옵저버블이 도착하면 첫 번째 내부 옵저버블을 구독하고, 값이 도착하면 방출합니다.\n  하지만 다음 내부 옵저버블이 도착하면, 이전 내부 값을 구독 해제하고 새 값을 구독합니다.\n- [`exhaustAll()`](https://rxjs.dev/api/operators/exhaustAll) — 첫 번째 내부 옵저버블이 도착하면 첫 번째 내부 옵저버블을 구독하고, 값이 도착하면 방출합니다.\n  첫 번째 내부 옵저버블이 완료될 때까지 새로 도착하는 모든 내부 옵저버블을 버리고 다음 내부 옵저버블을 기다립니다.\n\n대부분의 배열 라이브러리에서 [`map()`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/map) 과\n[`flat()`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/flat) (또는 `flatten()`) 을 합쳐\n[`flatMap()`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap) 으로 제공하듯이,\n모든 RxJS의 평탄화 연산자에는 [`concatMap()`](https://rxjs.dev/api/operators/concatMap), [`mergeMap()`](https://rxjs.dev/api/operators/mergeMap), [`switchMap()`](https://rxjs.dev/api/operators/switchMap), [`exhaustMap()`](https://rxjs.dev/api/operators/exhaustMap)\n과 같이 매핑할 수 있는 연산자가 제공됩니다.\n\n## Marble diagrams(마블 다이어그램)\n\n연산자의 작동 방식을 텍스트로만 설명하기는 어렵습니다.\n많은 연산자들의 동작은 시간과 관련되어 있는데 (예: delay, sample, throttle, debounce)\n이 동작들은 텍스트보단 다이어그램으로 표현하는 게 나은 방법입니다.\n_마블 다이어그램_ 은 연산자의 작동을 시각적으로 표현한 것으로,\n입력 옵저버블(들), 연산자와 연산자의 매개 변수, 출력 옵저버블을 포함하고 있습니다.\n\n> 마블 다이어그램에서 시간은 오른쪽으로 흐르며,\n> 옵저버블에서 값(\"마블\")이 방출되는 방식을 설명합니다.\n\n아래는 마블 다이어그램의 설명도입니다.\n\n![마블 다이어그램 설명도](https://raw.githubusercontent.com/ReactiveX/rxjs/467c4e89ce6f3fcedcf6127ea38d7ce79d32d0f6/docs_app/src/assets/images/guide/marble-diagram-anatomy.svg)\n\n이 문서 사이트(역: RxJS 공식 문서)에서, 마블 다이어그램은 연산자의 작동 방식을 설명하기 위해 광범위하게 사용됩니다.\n물론 다른 컨텍스트(예: 화이트보드, 유닛 테스트)에서도 유용하게 사용될 수 있습니다.\n\n## 연산자 카테고리\n\n목적 단위로 연산자를 구분하면, 생성, 변환, 필터링, 결합, 멀티캐스팅, 에러 처리, 유틸리티 등으로 분류할 수 있습니다.\n아래의 목록에서 모든 연산자를 카테고리별로 구분해두었습니다.\n\n전체 목록은 [이 페이지](https://rxjs.dev/api) 에서 볼 수 있습니다.\n\n### <a id=\"생성-연산자\"></a>생성 연산자\n\n- [`ajax`](https://rxjs.dev/api/ajax/ajax)\n- [`bindCallback`](https://rxjs.dev/api/index/function/bindCallback)\n- [`bindNodeCallback`](https://rxjs.dev/api/index/function/bindNodeCallback)\n- [`defer`](https://rxjs.dev/api/index/function/defer)\n- [`empty`](https://rxjs.dev/api/index/function/empty)\n- [`from`](https://rxjs.dev/api/index/function/from)\n- [`fromEvent`](https://rxjs.dev/api/index/function/fromEvent)\n- [`fromEventPattern`](https://rxjs.dev/api/index/function/fromEventPattern)\n- [`generate`](https://rxjs.dev/api/index/function/generate)\n- [`interval`](https://rxjs.dev/api/index/function/interval)\n- [`of`](https://rxjs.dev/api/index/function/of)\n- [`range`](https://rxjs.dev/api/index/function/range)\n- [`throwError`](https://rxjs.dev/api/index/function/throwError)\n- [`timer`](https://rxjs.dev/api/index/function/timer)\n- [`iif`](https://rxjs.dev/api/index/function/iif)\n\n### <a id=\"결합-생성-연산자\"></a>결합 생성 연산자\n\n결합 생성 연산자는 결합 기능을 갖고 있는 옵저버블 생성 연산자들입니다.\n여러 소스 옵저버블의 값들을 방출하죠.\n\n- [`combineLatest`](https://rxjs.dev/api/index/function/combineLatest)\n- [`concat`](https://rxjs.dev/api/index/function/concat)\n- [`forkJoin`](https://rxjs.dev/api/index/function/forkJoin)\n- [`merge`](https://rxjs.dev/api/index/function/merge)\n- [`partition`](https://rxjs.dev/api/index/function/partition)\n- [`race`](https://rxjs.dev/api/index/function/race)\n- [`zip`](https://rxjs.dev/api/index/function/zip)\n\n### 변형 연산자\n\n- [`buffer`](https://rxjs.dev/api/operators/buffer)\n- [`bufferCount`](https://rxjs.dev/api/operators/bufferCount)\n- [`bufferTime`](https://rxjs.dev/api/operators/bufferTime)\n- [`bufferToggle`](https://rxjs.dev/api/operators/bufferToggle)\n- [`bufferWhen`](https://rxjs.dev/api/operators/bufferWhen)\n- [`concatMap`](https://rxjs.dev/api/operators/concatMap)\n- [`concatMapTo`](https://rxjs.dev/api/operators/concatMapTo)\n- [`exhaust`](https://rxjs.dev/api/operators/exhaust)\n- [`exhaustMap`](https://rxjs.dev/api/operators/exhaustMap)\n- [`expand`](https://rxjs.dev/api/operators/expand)\n- [`groupBy`](https://rxjs.dev/api/operators/groupBy)\n- [`map`](https://rxjs.dev/api/operators/map)\n- [`mapTo`](https://rxjs.dev/api/operators/mapTo)\n- [`mergeMap`](https://rxjs.dev/api/operators/mergeMap)\n- [`mergeMapTo`](https://rxjs.dev/api/operators/mergeMapTo)\n- [`mergeScan`](https://rxjs.dev/api/operators/mergeScan)\n- [`pairwise`](https://rxjs.dev/api/operators/pairwise)\n- [`partition`](https://rxjs.dev/api/operators/partition)\n- [`pluck`](https://rxjs.dev/api/operators/pluck)\n- [`scan`](https://rxjs.dev/api/operators/scan)\n- [`switchScan`](https://rxjs.dev/api/operators/switchScan)\n- [`switchMap`](https://rxjs.dev/api/operators/switchMap)\n- [`switchMapTo`](https://rxjs.dev/api/operators/switchMapTo)\n- [`window`](https://rxjs.dev/api/operators/window)\n- [`windowCount`](https://rxjs.dev/api/operators/windowCount)\n- [`windowTime`](https://rxjs.dev/api/operators/windowTime)\n- [`windowToggle`](https://rxjs.dev/api/operators/windowToggle)\n- [`windowWhen`](https://rxjs.dev/api/operators/windowWhen)\n\n### 필터링 연산자\n\n- [`audit`](https://rxjs.dev/api/operators/audit)\n- [`auditTime`](https://rxjs.dev/api/operators/auditTime)\n- [`debounce`](https://rxjs.dev/api/operators/debounce)\n- [`debounceTime`](https://rxjs.dev/api/operators/debounceTime)\n- [`distinct`](https://rxjs.dev/api/operators/distinct)\n- [`distinctUntilChanged`](https://rxjs.dev/api/operators/distinctUntilChanged)\n- [`distinctUntilKeyChanged`](https://rxjs.dev/api/operators/distinctUntilKeyChanged)\n- [`elementAt`](https://rxjs.dev/api/operators/elementAt)\n- [`filter`](https://rxjs.dev/api/operators/filter)\n- [`first`](https://rxjs.dev/api/operators/first)\n- [`ignoreElements`](https://rxjs.dev/api/operators/ignoreElements)\n- [`last`](https://rxjs.dev/api/operators/last)\n- [`sample`](https://rxjs.dev/api/operators/sample)\n- [`sampleTime`](https://rxjs.dev/api/operators/sampleTime)\n- [`single`](https://rxjs.dev/api/operators/single)\n- [`skip`](https://rxjs.dev/api/operators/skip)\n- [`skipLast`](https://rxjs.dev/api/operators/skipLast)\n- [`skipUntil`](https://rxjs.dev/api/operators/skipUntil)\n- [`skipWhile`](https://rxjs.dev/api/operators/skipWhile)\n- [`take`](https://rxjs.dev/api/operators/take)\n- [`takeLast`](https://rxjs.dev/api/operators/takeLast)\n- [`takeUntil`](https://rxjs.dev/api/operators/takeUntil)\n- [`takeWhile`](https://rxjs.dev/api/operators/takeWhile)\n- [`throttle`](https://rxjs.dev/api/operators/throttle)\n- [`throttleTime`](https://rxjs.dev/api/operators/throttleTime)\n\n### <a id=\"결합-연산자\"></a>결합 연산자\n\n위의 [결합 생성 연산자](#결합-생성-연산자) 카테고리도 살펴보세요.\n\n- [`combineLatestAll`](https://rxjs.dev/api/operators/combineLatestAll)\n- [`concatAll`](https://rxjs.dev/api/operators/concatAll)\n- [`exhaustAll`](https://rxjs.dev/api/operators/exhaustAll)\n- [`mergeAll`](https://rxjs.dev/api/operators/mergeAll)\n- [`switchAll`](https://rxjs.dev/api/operators/switchAll)\n- [`startWith`](https://rxjs.dev/api/operators/startWith)\n- [`withLatestFrom`](https://rxjs.dev/api/operators/withLatestFrom)\n\n### 멀티캐스팅 연산자\n\n- [`multicast`](https://rxjs.dev/api/operators/multicast)\n- [`publish`](https://rxjs.dev/api/operators/publish)\n- [`publishBehavior`](https://rxjs.dev/api/operators/publishBehavior)\n- [`publishLast`](https://rxjs.dev/api/operators/publishLast)\n- [`publishReplay`](https://rxjs.dev/api/operators/publishReplay)\n- [`share`](https://rxjs.dev/api/operators/share)\n\n### 에러 처리 연산자\n\n- [`catchError`](https://rxjs.dev/api/operators/catchError)\n- [`retry`](https://rxjs.dev/api/operators/retry)\n- [`retryWhen`](https://rxjs.dev/api/operators/retryWhen)\n\n### 유틸리티 연산자\n\n- [`tap`](https://rxjs.dev/api/operators/tap)\n- [`delay`](https://rxjs.dev/api/operators/delay)\n- [`delayWhen`](https://rxjs.dev/api/operators/delayWhen)\n- [`dematerialize`](https://rxjs.dev/api/operators/dematerialize)\n- [`materialize`](https://rxjs.dev/api/operators/materialize)\n- [`observeOn`](https://rxjs.dev/api/operators/observeOn)\n- [`subscribeOn`](https://rxjs.dev/api/operators/subscribeOn)\n- [`timeInterval`](https://rxjs.dev/api/operators/timeInterval)\n- [`timestamp`](https://rxjs.dev/api/operators/timestamp)\n- [`timeout`](https://rxjs.dev/api/operators/timeout)\n- [`timeoutWith`](https://rxjs.dev/api/operators/timeoutWith)\n- [`toArray`](https://rxjs.dev/api/operators/toArray)\n\n### 조건부 연산자\n\n- [`defaultIfEmpty`](https://rxjs.dev/api/operators/defaultIfEmpty)\n- [`every`](https://rxjs.dev/api/operators/every)\n- [`find`](https://rxjs.dev/api/operators/find)\n- [`findIndex`](https://rxjs.dev/api/operators/findIndex)\n- [`isEmpty`](https://rxjs.dev/api/operators/isEmpty)\n\n### 수학 연산자\n\n- [`count`](https://rxjs.dev/api/operators/count)\n- [`max`](https://rxjs.dev/api/operators/max)\n- [`min`](https://rxjs.dev/api/operators/min)\n- [`reduce`](https://rxjs.dev/api/operators/reduce)\n\n## 커스텀 연산자 생성하기\n\n### 새 연산자를 생성하려면...\n\n`pipe()` 함수를 사용하세요.\n\n코드에 일반적으로 사용되는 연산자 시퀀스가 있는 경우,\n`pipe()` 함수를 이용해 시퀀스를 새 연산자로 추출하세요.\n흔하지 않은 시퀀스여도 단일 연산자로 나누면 가독성이 향상될 수 있습니다.\n\n예를 들어, 홀수 값을 삭제하고 짝수 값을 두 배로 하는 함수를 만들어봅시다.\n\n```ts\nimport { pipe, filter, map } from \"rxjs\";\nfunction discardOddDoubleEven() {\n  return pipe(\n    filter((v) => !(v % 2)),\n    map((v) => v + v),\n  );\n}\n```\n\n(`pipe()` 함수는 옵저버블의 `.pipe()` 메서드와 유사하지만 같지는 않습니다.)\n\n### 처음부터 새 연산자 생성하기\n\n더 복잡하지만, 기존 연산자의 조합으로 만들 수 없는 연산자가 필요한 경우에는\n다음과 같이 옵저버블 생성자를 사용해 처음부터 연산자를 작성할 수 있습니다.\n\n```ts\nimport { Observable, of } from \"rxjs\";\nfunction delay<T>(delayInMillis: number) {\n  return (observable: Observable<T>) =>\n    new Observable<T>((subscriber) => {\n      // 이 함수는 옵저버블이 구독될 때마다 호출됩니다.\n      const allTimerIDs = new Set();\n      let hasCompleted = false;\n      const subscription = observable.subscribe({\n        next(value) {\n          // 타이머를 시작하여 다음 값을 지연합니다.\n          const timerID = setTimeout(() => {\n            subscriber.next(value);\n            // 값을 push한 후 타이머를 정리합니다.\n            allTimerIDs.delete(timerID);\n            // 소스가 완료되고, 실행 중인 타이머가 더 이상 없으면\n            // 결과 옵저버블을 완료할 수 있습니다.\n            if (hasCompleted && allTimerIDs.size === 0) {\n              subscriber.complete();\n            }\n          }, delayInMillis);\n          allTimerIDs.add(timerID);\n        },\n        error(err) {\n          // 에러를 전파하고 있는지 확인해야 합니다.\n          subscriber.error(err);\n        },\n        complete() {\n          hasCompleted = true;\n          // 타이머가 아직 작동 중이라면, 이 코드는 작동되지 않겠죠!\n          if (allTimerIDs.size === 0) {\n            subscriber.complete();\n          }\n        },\n      });\n      // 해제 로직을 반환합니다.\n      // 결과 오류, 완료, 또는 구독 취소 시에 호출됩니다.\n      return () => {\n        subscription.unsubscribe();\n        // 타이머를 정리합니다.\n        for (const timerID of allTimerIDs) {\n          clearTimeout(timerID);\n        }\n      };\n    });\n}\n// 한 번 실행해보세요!\nof(1, 2, 3).pipe(delay(1000)).subscribe(console.log);\n```\n\n다음 사항들을 주의하세요.\n\n1. `next()`, `error()`, `complete()`의 세 가지 옵저버 기능을 모두 구현하세요.\n2. 옵저버블이 완료되었을 때 정리하는 \"해제\" 기능을 구현하세요(보류 중인 timeout을 구독 취소하고 지울 수 있게요!).\n3. 옵저버블 생성자에 전달된 함수에서 해당 함수를 반환하세요.\n\n위의 예제는 당연히 예시일 뿐이고, [`delay()`](https://rxjs.dev/api/operators/delay) 연산자가 이미 준비되어 있습니다.\n"},{"fields":{"slug":"/rxjs-observer/"},"frontmatter":{"date":"2022.04.12","update":"2022.04.12","title":"[번역] RxJS 공식 문서 #Observer","tags":["RxJS","Reactive Programming"],"description":"🇰🇷 Observer, 너는 또 누구냐-"},"rawMarkdownBody":"\n## 프롤로그\n\n안녕하세요! 제로입니다.\n이번 게시물에는 공식 문서 가이드의 [Observer](https://rxjs.dev/guide/observer) 문서를 번역해보려 합니다.\n저번 문서인 [RxJS Observable 공식 문서 번역](https://6h15m.github.io/rxjs-observable/) 을 읽고 오시면 옵저버에 대해서 훨씬 더 쉽게 이해하실 수 있을 거에요!\n\n## Observer(옵저버) 소개\n\n**옵저버란?** 옵저버는 옵저버블에 의해 전달되는 값의 소비자입니다.\n간단히 말하자면 콜백 세트로, 옵저버블에서 제공하는 타입의 알림(: `next`, `error`, `complete`)에 대해 각자 하나씩 제공하게 됩니다.\n다음은 일반적인 옵저버 객체의 예시입니다.\n\n```ts\nconst observer = {\n  next: (x) => console.log(\"옵저버가 next 값을 전달받았습니다: \" + x),\n  error: (err) => console.error(\"옵저버가 에러를 전달받았습니다: \" + err),\n  complete: () => console.log(\"옵저버가 complete 알림을 전달받았습니다.\"),\n};\n```\n\n옵저버를 사용하려면, 옵저버블의 `subscribe`에 전달해야 합니다.\n\n```ts\nobservable.subscribe(observer);\n```\n\n> 옵저버는 옵저버블이 전달할 수 있는 알림 타입에 대해 각 하나씩, 총 세 개의 콜백을 가진 객체입니다.\n\nRxJS의 옵저버는 _부분적일_ 수 있습니다.\n콜백 중 하나를 제공하지 않았을 때, 해당 콜백이 없기 때문에 옵저버에서 일부 알림이 무시되는 것을 제외하면 옵저버블의 실행이 정상적으로 수행됩니다.\n\n아래의 예제는 `complete` 콜백을 제공하지 않은 `옵저버`입니다.\n\n```ts\nconst observer = {\n  next: (x) => console.log(\"옵저버가 next 값을 전달받았습니다: \" + x),\n  error: (err) => console.error(\"옵저버가 에러를 전달받았습니다: \" + err),\n};\n```\n\n`옵저버블`을 구독할 때, next 콜백을 `옵저버` 객체에 연결하지 않고 인수로 전달할 수도 있습니다.\n\n```ts\nobservable.subscribe((x) =>\n  console.log(\"옵저버가 next 값을 전달받았습니다: \" + x),\n);\n```\n\n`observable.subscribe`가 내부적으로 콜백 인수를 `next` 핸들러로 사용하는 `옵저버` 객체를 생성하기에 가능한 일입니다.\n"},{"fields":{"slug":"/rxjs-observable/"},"frontmatter":{"date":"2022.04.11","update":"2022.04.11","title":"[번역] RxJS 공식 문서 #Observable","tags":["RxJS","Reactive Programming"],"description":"🇰🇷 Observable, 너는 누구냐-"},"rawMarkdownBody":"\n## 프롤로그\n\n안녕하세요! 제로입니다.\n저번의 [RxJS 공식 문서 OVERVIEW 번역](https://6h15m.github.io/rxjs-overview/) 에 이어,\n공식 문서 가이드의 [Observable](https://rxjs.dev/guide/observable) 문서를 번역해보려 합니다.\n\n## Observable(옵저버블) 소개\n\n옵저버블은 여러 값들에 대한 \"Lazy Push\" 콜렉션입니다.\n\n|          | Single                                                                                             | Multiple                                                                                         |\n| -------- | -------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ |\n| **Pull** | [`함수`](https://developer.mozilla.org/ko/docs/Glossary/Function)                                  | [`Iterator`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Iteration_protocols) |\n| **Push** | [`Promise`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise) | [`옵저버블`](https://rxjs.dev/api/index/class/Observable)                                        |\n\n**예제.** 아래의 코드는 구독 즉시(동기적으로) `1`, `2`, `3`을 push하고,\n구독 후 1초가 지났을 때 `4`를 push해 완료되는 옵저버블입니다.\n\n```ts\nimport { Observable } from \"rxjs\";\n\nconst observable = new Observable((subscriber) => {\n  subscriber.next(1);\n  subscriber.next(2);\n  subscriber.next(3);\n  setTimeout(() => {\n    subscriber.next(4);\n    subscriber.complete();\n  }, 1000);\n});\n```\n\n옵저버블을 호출해 값을 확인하려면, 이 옵저버블을 구독해야 합니다.\n\n```ts\nimport { Observable } from \"rxjs\";\n\nconst observable = new Observable((subscriber) => {\n  subscriber.next(1);\n  subscriber.next(2);\n  subscriber.next(3);\n  setTimeout(() => {\n    subscriber.next(4);\n    subscriber.complete();\n  }, 1000);\n});\n\nconsole.log(\"방금 구독되었어요!\");\nobservable.subscribe({\n  next(x) {\n    console.log(\"값: \" + x);\n  },\n  error(err) {\n    console.error(\"문제가 발생했습니다: \" + err);\n  },\n  complete() {\n    console.log(\"완료!\");\n  },\n});\nconsole.log(\"구독 직후입니다!\");\n```\n\n콘솔을 확인해보겠습니다.\n\n```none\n방금 구독되었어요!\n값: 1\n값: 2\n값: 3\n구독 직후입니다!\n값: 4\n완료!\n```\n\n## Pull vs Push\n\n_Pull_ 과 _Push_ 는 데이터 _생산자_ 가 데이터 _소비자_ 와 통신하는 방법에 해당하는 두 가지 프로토콜입니다.\n\n**Pull이란?** Pull 시스템에서는, 소비자가 데이터 생산자로부터 데이터를 받을 타이밍을 결정합니다.\n즉, 생산자는 데이터가 소비자에게 언제 전달되는지 알지 못하죠.\n\n모든 JavaScript 함수는 Pull 시스템입니다.\n함수는 데이터 생산자이며, 함수를 호출하는 코드는 호출 시 _하나의_ 리턴 값을 \"pull\"합니다.\n\nES2015에서는 Pull 시스템의 또 다른 형태인\n[제너레이터 함수와 이터레이터](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/function*) (`function*`)가 등장했습니다.\n이 개념에서는 `iterator.next()`를 호출하는 코드(소비자)가 이터레이터(생산자)에서 _여러 개_ 의 값을 \"pull\"합니다.\n\n|          | 생산자                             | 소비자                                      |\n| -------- | ---------------------------------- | ------------------------------------------- |\n| **Pull** | **수동적:** 요청 시 데이터 생산    | **능동적:** 데이터를 요청하는 타이밍을 결정 |\n| **Push** | **능동적:** 자체적으로 데이터 생산 | **수동적:** 전달받은 데이터에 반응          |\n\n**Push란?** Push 시스템에서는, 소비자에게 데이터를 보내는 타이밍을 생산자가 결정합니다.\n즉, 소비자는 언제 데이터를 전달받을지 알 수 없죠.\n\nJavaScript에서 가장 흔하게 볼 수 있는 Push 시스템에는 Promise가 있습니다.\nPromise(생산자)는 resolve된 값을 등록된 콜백 함수(소비자)에 전달합니다.\n함수와는 달리, Promise 자체적으로 값이 콜백에 \"push\"되는 시기를 결정하죠.\n\nRxJS는 JavaScript를 위한 새로운 Push 시스템, 옵저버블을 도입했습니다.\n옵저버블은 여러 값들을 생산해, 그 값들을 옵저버(소비자)에게 \"push\"합니다.\n\n- **함수**는 호출 시 단일 값을 동기적으로 리턴하는 지연 평가 계산입니다.\n- **제너레이터**는 호출 시 0부터 (잠재적으로) 무한대까지의 값들을 동기적으로 리턴하는 지연 평가 계산입니다.\n- **Promise**는 단일 값을 리턴할 수도 있고 리턴하지 않을 수도 있는 계산입니다.\n- **옵저버블**은 호출 시 0부터 (잠재적으로) 무한대까지의 값들을 동기적으로, 또는 비동기적으로 리턴하는 지연 평가 계산입니다.\n\n> 옵저버블을 Promise로 변환하는 것에 대한 자세한 정보가 알고 싶으시다면, [이 가이드 문서](https://rxjs.dev/deprecations/to-promise) 를 참조해 주세요.\n\n## 함수와 옵저버블\n\n옵저버블은 EventEmitter나 여러 값을 다루는 Promise와 같지 않습니다.\n옵저버블은 때에 따라 EventEmitter _같은_ 역할을 수행할 수도 있지만, 일반적으로 EventEmitter처럼 작동하지는 않습니다.\n\n> 옵저버블은 인수 없는 함수이지만, 여러 값을 허용하도록 인수들을 일반화합니다.\n>\n> ~~역: 무슨 말인지 저도 이해 못 함~~\n\n밑의 예제를 살펴봅시다.\n\n```ts\nfunction foo() {\n  console.log(\"안녕!\");\n  return 42;\n}\n\nconst x = foo.call(); // foo()와 같음\nconsole.log(x);\nconst y = foo.call(); // foo()와 같음\nconsole.log(y);\n```\n\n출력은 아마 이렇게 될 것입니다.\n\n```none\n\"안녕!\"\n42\n\"안녕!\"\n42\n```\n\n옵저버블을 이용해 같은 동작을 구현해보겠습니다.\n\n```ts\nimport { Observable } from \"rxjs\";\n\nconst foo = new Observable((subscriber) => {\n  console.log(\"안녕!\");\n  subscriber.next(42);\n});\n\nfoo.subscribe((x) => {\n  console.log(x);\n});\nfoo.subscribe((y) => {\n  console.log(y);\n});\n```\n\n똑같이 출력됩니다.\n\n```none\n\"안녕!\"\n42\n\"안녕!\"\n42\n```\n\n이는 함수와 옵저버블 모두 지연 평가에 해당하기 때문입니다.\n함수를 호출하지 않았다면, `console.log('안녕!')`은 발생하지 않았겠죠?\n옵저버블에서도 마찬가지로 `subscribe`로 \"호출\"하지 않았다면 `console.log('안녕!')`은 발생하지 않았을 것입니다.\n\n추가적으로, \"호출\"과 \"구독\"은 분리되어 있는 연산입니다.\n두 개의 함수 호출은 두 개의 개별 사이트 이펙트를 유발하고,\n두 개의 옵저버블 구독은 두 개의 개별 사이드 이펙트를 유발합니다.\n사이드 이펙트를 공유하며 구독자의 존재와 관계없이 실행하는 EventEmitter와 달리,\n옵저버블은 실행을 공유하지 않으며 지연적으로 동작합니다.\n\n> 옵저버블을 구독하는 것은 함수를 호출하는 것과 유사합니다.\n\n옵저버블이 비동기적이라고 생각하는 경우도 있지만, 그건 사실이 아닙니다.\n다음과 같이 로그 안에서 함수를 호출해 봅시다.\n\n```js\nconsole.log(\"이전\");\nconsole.log(foo.call());\nconsole.log(\"이후\");\n```\n\n이렇게 출력되겠군요.\n\n```none\n\"이전\"\n\"안녕!\"\n42\n\"이후\"\n```\n\n옵저버블로 구현해도 이 동작은 동일합니다.\n\n```js\nconsole.log(\"이전\");\nfoo.subscribe((x) => {\n  console.log(x);\n});\nconsole.log(\"이후\");\n```\n\n출력은 이렇습니다.\n\n```none\n\"이전\"\n\"안녕!\"\n42\n\"이후\"\n```\n\n이는 `foo` 옵저버블의 구독이 완벽히 동기적이라는 것을 증명하죠.(마치 함수처럼요!)\n\n> 옵저버블은 값을 동기적으로, 또는 비동기적으로 전달할 수 있습니다.\n\n옵저버블과 함수의 차이점은 무엇일까요? **옵저버블은 시간이 지남에 따라 여러 개의 값을 \"리턴\"할 수 있습니다.** 함수에선 불가능한 작업이죠.\n\n```js\nfunction foo() {\n  console.log(\"안녕!\");\n  return 42;\n  return 100; // 절대 발생할 수 없는 죽은 코드입니다.\n}\n```\n\n함수는 오직 하나의 값만 리턴할 수 있지요. 하지만 옵저버블은, 이렇게 할 수 있습니다.\n\n```ts\nimport { Observable } from \"rxjs\";\n\nconst foo = new Observable((subscriber) => {\n  console.log(\"안녕!\");\n  subscriber.next(42);\n  subscriber.next(100); // 다른 값을 \"리턴\"\n  subscriber.next(200); // 또 다른 \"리턴\"\n});\n\nconsole.log(\"이전\");\nfoo.subscribe((x) => {\n  console.log(x);\n});\nconsole.log(\"이후\");\n```\n\n동기적으로 출력된 것을 보죠.\n\n```none\n\"이전\"\n\"안녕!\"\n42\n100\n200\n\"이후\"\n```\n\n물론, 값들을 비동기적으로 \"리턴\"할 수도 있습니다.\n\n```ts\nimport { Observable } from \"rxjs\";\n\nconst foo = new Observable((subscriber) => {\n  console.log(\"안녕!\");\n  subscriber.next(42);\n  subscriber.next(100);\n  subscriber.next(200);\n  setTimeout(() => {\n    subscriber.next(300); // happens asynchronously\n  }, 1000);\n});\n\nconsole.log(\"이전\");\nfoo.subscribe((x) => {\n  console.log(x);\n});\nconsole.log(\"이후\");\n```\n\n출력은 아래와 같습니다.\n\n```none\n\"이전\"\n\"안녕!\"\n42\n100\n200\n\"이후\"\n300\n```\n\n정리:\n\n- `func.call()`은 _동기적으로 하나의 값을 주는 것_ 을 의미합니다.\n- `observable.subscribe()`는 _동기적으로든 비동기적으로든 개수 상관없이 값을 주는 것_ 을 의미합니다.\n\n## 옵저버블의 구석구석\n\n옵저버블은 `new Observable`이나 생성 연산자를 통해 **생성**되며,\n옵저버를 통해 **구독**되며,\n옵저버에게 `next` / `error` / `complete` 알림을 전달하기 위해 **실행**되며,\n이 실행은 **해제**될 수 있습니다.\n이 4가지 동작들은 모두 옵저버블 인스턴스로 인코딩되지만,\n일부는 옵저버 또는 구독과 같은 다른 타입과 관련되어 있습니다.\n\n아래는 옵저버블의 핵심 기능들입니다.\n\n- 옵저버블 **생성**\n- 옵저버블 **구독**\n- 옵저버블 **실행**\n- 옵저버블 **해제**\n\n### 옵저버블 생성\n\n`Observable` 생성자는 하나의 인수, `subscribe` 함수만을 취합니다.\n\n초당 한 번씩 구독자에게 `'안녕!'`문자열을 내보내는 옵저버블을 구현해 보겠습니다.\n\n```ts\nimport { Observable } from \"rxjs\";\n\nconst observable = new Observable(function subscribe(subscriber) {\n  const id = setInterval(() => {\n    subscriber.next(\"안녕!\");\n  }, 1000);\n});\n```\n\n> 일반적으로는 생성 함수(예: `of`, `from`, `interval` 등)를 이용하지만,\n> `new Observable`을 이용해서도 옵저버블을 생성할 수 있습니다.\n\n위의 예제에서, `subscribe` 함수는 옵저버블을 설명하는 데 있어 가장 중요한 부분입니다. 이 \"구독\"이 무엇을 의미하는지 살펴봅시다.\n\n### 옵저버블 구독\n\n예제의 `observable` 옵저버블은 이렇게 _구독_ 될 수 있습니다.\n\n```ts\nobservable.subscribe((x) => console.log(x));\n```\n\n`observable.subscribe`와 `new Observable(function subscribe(subscriber) {...})`의 `subscribe`가 같은 이름을 가진 건 우연이 아닙니다.\n이 둘은 라이브러리 내부에서는 다르지만, 개념적으로 동일하다고 생각할 수 있습니다.\n\n이는 동일한 옵저버블에 대한 여러 개의 옵저버들 사이에서 `subscribe` 호출이 공유되지 않는다는 것을 보여줍니다.\n옵저버를 통해 `observable.subscribe`를 호출할 때, 해당 구독자에 대해 `new Observable(function subscribe(subscriber) {...})`의 `subscribe` 함수가 실행됩니다.\n`observable.subscribe`에 대한 각 호출은 해당 구독자에 대해 자체적으로 독립된 기반을 발생시킵니다.\n\n> 옵저버블을 구독하는 것은 함수를 호출하여, 데이터가 전달될 콜백을 제공하는 것과 같습니다.\n\n이는 `addEventListener` / `removeEventListener`와 같은 이벤트 핸들러 API와 확연히 차이가 있습니다.\n`observable.subscribe`에서, 주어진 옵저버는 옵저버블의 리스너로 등록되지 았습니다.\n옵저버블은 등록된 옵저버들의 목록도 갖고 있지 않죠.\n\n`subscribe` 호출은 단순히 \"옵저버블의 실행\"을 시작하고 이 실행의 옵저버에게 값이나 이벤트를 전달할 뿐입니다.\n\n### 옵저버블 실행\n\n`new Observable(function subscribe(subscriber) {...})` 내부의 코드는 \"옵저버블의 실행\", 즉 구독한 각 옵저버에서만 발생하는 지연 평가를 나타냅니다.\n이 실행은 시간에 지남에 따라 동기적으로, 또는 비동기적으로 여러 값들을 생산합니다.\n\n옵저버블의 실행이 전달할 수 있는 3가지 타입의 값이 있습니다.\n\n- \"Next\" 알림: 숫자, 문자열, 객체 등의 값들을 전송합니다.\n- \"Error\" 알림: JavaScript Error 또는 예외를 전송합니다.\n- \"Complete\" 알림: 값을 내보내지 않습니다.\n\n\"Next\" 알림은 가장 중요하고 자주 쓰이는 타입으로, 구독자에게 전달되는 실제 데이터를 나타냅니다. \"Error\"와 \"Complete\" 알림은 옵저버블 실행 중 한 번만 발생할 수 있으며, 둘 중 하나만 발생할 수 있습니다.\n\n이러한 제약 조건은 정규 표현식으로 작성된 _옵저버블 문법_ 또는 _약속_ 으로 가장 잘 표현할 수 있습니다.\n\n```none\nnext*(error|complete)?\n```\n\n> 옵저버블 실행에서, 0에서 무한대 개수의 Next 알림이 전달될 수 있습니다. Error 또는 Complete 알림이 전달되면, 이후에는 아무것도 전달할 수 없습니다.\n\n3개의 Next 알림을 전달하고, 완료되는 옵저버블 실행 예제를 보겠습니다.\n\n```ts\nimport { Observable } from \"rxjs\";\n\nconst observable = new Observable(function subscribe(subscriber) {\n  subscriber.next(1);\n  subscriber.next(2);\n  subscriber.next(3);\n  subscriber.complete();\n});\n```\n\n옵저버블 약속은 엄격히 준수되므로, 다음 코드는 Next 알림 `4`를 전달하지 않습니다.\n\n```ts\nimport { Observable } from \"rxjs\";\n\nconst observable = new Observable(function subscribe(subscriber) {\n  subscriber.next(1);\n  subscriber.next(2);\n  subscriber.next(3);\n  subscriber.complete();\n  subscriber.next(4); // 약속에 위반되므로 전달되지 않습니다.\n});\n```\n\n`subscribe` 내부의 코드에서 예외 발생 시 Error 알림이 전달되게끔 `try`/`catch` 블록으로 감싸는 것도 좋은 방법입니다.\n\n```ts\nimport { Observable } from \"rxjs\";\n\nconst observable = new Observable(function subscribe(subscriber) {\n  try {\n    subscriber.next(1);\n    subscriber.next(2);\n    subscriber.next(3);\n    subscriber.complete();\n  } catch (err) {\n    subscriber.error(err); // 예외가 발생되면 에러 전달\n  }\n});\n```\n\n### 옵저버블 해제\n\n옵저버블은 무한하게 실행될 수 있으며, 옵저버는 일반적으로 제한된 시간 내에 실행을 중단하길 원하기 때문에, 실행을 취소하기 위한 API가 필요합니다.\n각 실행은 하나의 옵저버에만 독점적이므로, 옵저버가 값 수신을 완료하면 연산 또는 메모리 리소스를 낭비하지 않도록 실행을 중지할 수 있는 방법이 있어야 하죠.\n\n`observable.subscribe`가 호출되면, 옵저버는 새로 생성된 옵저버블 실행과 연결됩니다.\n이 호출은 `Subscription`이라는 객체도 리턴하죠.\n\n```ts\nconst subscription = observable.subscribe((x) => console.log(x));\n```\n\n`Subscription`은 진행 중인 실행을 나타내며, 실행을 취소할 수 있는 API를 가지고 있습니다.\n`Subscription` 타입에 대한 자세한 내용은 [여기](https://rxjs.dev/guide/subscription) 를 참조하세요.\n`subscription.unsubscribe()`로 진행 중인 실행을 취소할 수 있습니다.\n\n```ts\nimport { from } from \"rxjs\";\n\nconst observable = from([10, 20, 30]);\nconst subscription = observable.subscribe((x) => console.log(x));\n// 나중에는-\nsubscription.unsubscribe();\n```\n\n> 구독하면 현재 진행 중인 실행을 나타내는 Subscription을 반환하며, 이 객체의 `unsubscribe()`를 호출해 실행을 취소할 수 있습니다.\n\n`create()`를 이용해 옵저버블을 생성할 때, 각 옵저버블은 해당 실행의 리소스를 해제하는 방법을 정의해야 합니다.\n`function subscribe()` 내부의 커스텀 `unsubscribe` 함수를 리턴하는 방식으로 이를 정의할 수 있죠.\n\n`setInterval`을 이용한 예제를 보겠습니다.\n\n```js\nconst observable = new Observable(function subscribe(subscriber) {\n  // 인터벌 리소스에 대한 추적\n  const intervalId = setInterval(() => {\n    subscriber.next(\"안녕!\");\n  }, 1000);\n\n  // 인터벌 리소스를 취소하고 해제하는 방법 정의\n  return function unsubscribe() {\n    clearInterval(intervalId);\n  };\n});\n```\n\n`observable.subscribe`가 `new Observable(function subscribe() {...})`과 유사하듯이,\n`subscribe`에서 리턴한 `unsubscribe`는 개념적으로 `subscription.unsubscribe`와 유사합니다.\n사실, 이러한 개념들을 둘러싼 ReactiveX 타입들을 제거하면 매우 간단한 JavaScript 코드만이 남습니다.\n\n```js\nfunction subscribe(subscriber) {\n  const intervalId = setInterval(() => {\n    subscriber.next(\"안녕!\");\n  }, 1000);\n\n  return function unsubscribe() {\n    clearInterval(intervalId);\n  };\n}\n\nconst unsubscribe = subscribe({ next: (x) => console.log(x) });\n\n// 나중에는-\nunsubscribe(); // 리소스 해제\n```\n\n옵저버블, 옵저버, 구독과 같은 Rx 타입들을 사용하는 이유는 안정성(예: 옵저버블 약속)과 연산자와의 결합성을 얻기 위해서입니다.\n"},{"fields":{"slug":"/rxjs-overview/"},"frontmatter":{"date":"2022.04.06","update":"2022.04.06","title":"[번역] RxJS 공식 문서 #OVERVIEW","tags":["RxJS","Reactive Programming"],"description":"🇰🇷 RxJS가 뭐예요?"},"rawMarkdownBody":"\n## 프롤로그\n\n안녕하세요! 제로입니다.\n최근 RxJS를 사용할 일이 생겨 열심히 학습하던 중, [Learn RxJS](https://www.learnrxjs.io/) 라는 문서를 발견해 번역해보고 있었어요.\n공식 문서보다 조금 더 알기 쉽게 설명되어 있는 것 같아 학습에 큰 도움이 되었지만,\nv6 이후로 업데이트되지 않아 deprecated 된 자료들이 꽤 많았습니다.\n\n[저희의 Learn RxJS](https://chasethestar.gitbook.io/ko.learn-rxjs) 가 정확한 학습 자료로 거듭나려면\n**공식 문서를 먼저 학습해야겠다**는 판단이 생기게 되었고, [OVERVIEW](https://rxjs.dev/guide/overview)에 해당하는 영역부터 번역~~의역~~해나가 보려고 합니다.\n\n## RxJS 소개\n\nRxJS는 [Observable(옵저버블)](https://6h15m.github.io/rxjs-observable) 시퀀스를 이용해 비동기 및 이벤트 기반 프로그램을 구성하기 위한 라이브러리입니다.\n옵저버블, 옵저버블에 종속되는 타입들(Observer, Schedulers, Subjects),\n`Array` 메소드(`map`, `filter`, `reduce`, `every` 등)에서 영감받은 Operator(연산자)를 제공하여\n비동기 이벤트를 콜렉션처럼 다룰 수 있게 하죠.\n\n> 이벤트 처리를 위한 Lodash, **RxJS**\n\nReactiveX는 이벤트 시퀀스를 관리하는 이상적인 방법으로 [옵저버 패턴](https://en.wikipedia.org/wiki/Observer_pattern),\n[이터레이터 패턴](https://en.wikipedia.org/wiki/Iterator_pattern),\n[콜렉션을 다루는 함수형 프로그래밍](http://martinfowler.com/articles/collection-pipeline/#NestedOperatorExpressions) 을 결합하는 것을 택했습니다.\n\n### 비동기 이벤트를 관리하는 RxJS의 필수 개념\n\n- **Observable** - `옵저버블`: 호출 가능한 미래의 값 또는 이벤트에 대한 집합\n- **Observer** - `옵저버`: 옵저버블이 제공하는 값을 소비할 수 있는 콜백 함수의 집합\n- **Subscription** - `구독`: 옵저버블의 실행\n- **Operators** - `연산자`: `map`, `filter`, `concat`, `reduce` 같은 연산으로 컬렉션을 처리(함수형 프로그래밍 스타일)하는 순수함수\n- **Subject** - `서브젝트`: EventEmitter와 동일하게, 값 또는 이벤트를 여러 옵저버에 멀티캐스팅할 수 있게 하는 옵저버블의 한 종류\n- **Schedulers** - `스케쥴러`: 동시성을 제어하는 중앙 집중적인 스케쥴러(예: `setTimeout` 또는 `requestAnimationFrame` 등의 연산이 발생했을 때 조정이 가능하게 함)\n\n## 예제로 알아보는 RxJS\n\n보통은, 이벤트 리스너를 등록하죠.\n\n```ts\ndocument.addEventListener(\"click\", () => console.log(\"클릭하셨네요!\"));\n```\n\nRxJS를 사용한다면 이벤트 리스너 대신 옵저버블을 생성합니다.\n\n```ts\nimport { fromEvent } from \"rxjs\";\n\nfromEvent(document, \"click\").subscribe(() => console.log(\"클릭하셨네요!\"));\n```\n\n### 순수성\n\nRxJS가 강력한 이유는 순수함수를 이용해 값을 생성할 수 있기 때문입니다.\n이는 오류가 발생할 가능성이 낮다는 뜻이죠.\n\n일반적으로 우리는 '순수하지 않은', 다른 상태까지 망칠 수 있는 함수를 생성합니다.\n\n```ts\nlet count = 0;\ndocument.addEventListener(\"click\", () =>\n  console.log(`${++count}번이나 클릭하셨군요!`),\n);\n```\n\nRxJS를 사용한다면 상태는 서로 격리됩니다.\n\n```ts\nimport { fromEvent, scan } from \"rxjs\";\n\nfromEvent(document, \"click\")\n  .pipe(scan((count) => count + 1, 0))\n  .subscribe((count) => console.log(`${count}번이나 클릭하셨군요!`));\n```\n\n**scan** 연산자는 배열의 **reduce**와 유사하게 동작해,\n리턴된 콜백 함수의 값은 다음 콜백 함수의 매개 변수가 됩니다.\n\n### 유동성\n\nRxJS의 연산자들은 옵저버블을 통과하는 이벤트들의 흐름을 제어합니다. (종류도 다양하죠!)\n\nPlain JavaScript로 초당 최대 한 번으로 클릭을 제한하는 기능을 구현해보겠습니다.\n\n```ts\nlet count = 0;\nlet rate = 1000;\nlet lastClick = Date.now() - rate;\ndocument.addEventListener(\"click\", () => {\n  if (Date.now() - lastClick >= rate) {\n    console.log(`${++count}번 클릭하셨어요!`);\n    lastClick = Date.now();\n  }\n});\n```\n\nRxJS로도 구현해볼게요.\n\n```ts\nimport { fromEvent, throttleTime, scan } from \"rxjs\";\n\nfromEvent(document, \"click\")\n  .pipe(\n    throttleTime(1000),\n    scan((count) => count + 1, 0),\n  )\n  .subscribe((count) => console.log(`${count}번 클릭하셨어요!`));\n```\n\n다른 흐름 제어 연산자에는 [**filter**](https://rxjs.dev/api/operators/filter),\n[**delay**](https://rxjs.dev/api/operators/delay),\n[**debounceTime**](https://rxjs.dev/api/operators/debounceTime),\n[**take**](https://rxjs.dev/api/operators/take),\n[**takeUntil**](https://rxjs.dev/api/operators/takeUntil),\n[**distinct**](https://rxjs.dev/api/operators/distinct),\n[**distinctUntilChanged**](https://rxjs.dev/api/operators/distinctUntilChanged) 등이 있습니다.\n\n### 값\n\nRxJS에서는 옵저버블을 통과하는 값들을 변환할 수 있습니다.\n\nPlain JavaScript로 클릭할 때마다 현재 마우스의 x 좌표를 더하는 기능을 구현해보겠습니다.\n\n```ts\nlet count = 0;\nconst rate = 1000;\nlet lastClick = Date.now() - rate;\ndocument.addEventListener(\"click\", (event) => {\n  if (Date.now() - lastClick >= rate) {\n    count += event.clientX;\n    console.log(count);\n    lastClick = Date.now();\n  }\n});\n```\n\nRxJS로도 구현해볼게요.\n\n```ts\nimport { fromEvent, throttleTime, map, scan } from \"rxjs\";\n\nfromEvent(document, \"click\")\n  .pipe(\n    throttleTime(1000),\n    map((event) => event.clientX),\n    scan((count, clientX) => count + clientX, 0),\n  )\n  .subscribe((count) => console.log(count));\n```\n\n다른 값 관련 연산자에는 [**pluck**](https://rxjs.dev/api/operators/pluck), [**pairwise**](https://rxjs.dev/api/operators/pairwise), [**sample**](https://rxjs.dev/api/operators/sample) 등이 있습니다.\n"},{"fields":{"slug":"/github-snake/"},"frontmatter":{"date":"2021.07.20","update":"2021.07.20","title":"Github 프로필에 잔디 먹는 뱀 추가하기","tags":["Github"],"description":"👀 2분의 투자로, 역동적이고 재밌게 깃허브 꾸미기"},"rawMarkdownBody":"\n## 프롤로그\n\n안녕하세요! 제로입니다.\n[찬성 님의 facebook 포스팅][facebook-posting]을 보고 너무 신기해서 따라해보게 된 Github Action을 소개해 드릴게요.\n\n![github-contribution-grid-snake](https://user-images.githubusercontent.com/52748335/125471173-30203e61-5705-43f9-9a85-afa9d643d45a.gif)\n\n이번 포스팅에선, 저와 같이 Github README 꾸미기에 진심인 분들을 위해 커밋 내역을 먹는 뱀🐍을 추가하는 방법을 알려드리겠습니다!\n\n[데모 확인하기][demo-site]  \n[GitHub 확인하기][github-snk]\n\n## 1. Github 프로필 README 생성\n\n[Github][github-main]에 **Github 아이디**와 동일한 이름의 새 레포지토리를 생성합니다.\n생성 이전에 **Add a README file** 속성을 체크해 주세요.  \n생성해서 해당 레포지토리에 들어가 보면, 이런 안내문이 보입니다.\n<br/><br/>\n![special](https://user-images.githubusercontent.com/52748335/126091043-b18d702d-e01b-4a2b-9c5a-604c719de423.PNG)<br/>\n\nGithub 아이디를 이름으로 한 레포지토리는 특별한 레포지토리여서, 이 레포지토리의 README.md는\n깃허브 프로필에서 보입니다. 이렇게요!<br/><br/>\n![기존 리드미](https://user-images.githubusercontent.com/52748335/126091437-80f02fb3-8545-43e1-87ac-2ae6ee744561.PNG)\n<br/>\n\nGithub 블로그를 썼던 것처럼 마크다운 문법을 쓰면 저처럼 다양하게 꾸며볼 수 있습니다. Google에 **Github 프로필 꾸미기**로 검색하시면 방법을 많이 찾아볼 수 있습니다! 😁<br/>\n<br/>\n\n## 2. Github Actions 추가\n\n### Github Actions란?\n\n본격적으로 뱀 GIF를 생성하기 위해 프로필 레포지토리에 Github Actions를 추가해야 합니다.\n[Github Actions][github-actions]는 Github 이벤트를 기반으로 소프트웨어 workflow를 자동화할 수 있도록 하는 도구입니다. 더 자세히 알고 싶다면 [공식 문서][github-actions-docs]를 참고해 주세요.  \n여기에선 특정 시간마다 자신의 커밋 내역에 맞게 GIF를 새로 생성하기 위해 사용합니다.<br/><br/>\n![yml 추가](https://user-images.githubusercontent.com/52748335/126317621-76ce7c5c-c4a2-45ca-a9dd-b5188b36d73c.PNG)<br/>\n위와 같이 `.github` 디렉토리를 만들고, 그 안에 `workflows` 디렉토리를 만들어주세요.\n`workflows` 안에 `snake.yml`을 생성 후, 해당 내용을 작성해주세요.\n\n```\n# 커밋 먹는 뱀 그래프 생성을 위한 GitHub Action🐍\n\nname: Generate Snake\n\n# Action이 언제 구동될지 결정\n\non:\n  schedule:\n    # 6시간마다 한 번(수정 가능)\n    - cron: \"0 */6 * * *\"\n\n  # 자동으로 Action이 실행되도록 함\n  workflow_dispatch:\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n\n      # 뱀 생성\n      - uses: Platane/snk@master\n        id: snake-gif\n        with:\n          github_user_name: [Github 아이디]\n          # output branch에 gif, svg를 각각 생성\n          gif_out_path: dist/github-contribution-grid-snake.gif\n          svg_out_path: dist/github-contribution-grid-snake.svg\n\n      - run: git status\n\n      # 변경사항 push\n      - name: Push changes\n        uses: ad-m/github-push-action@master\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          branch: master\n          force: true\n\n      - uses: crazy-max/ghaction-github-pages@v2.1.3\n        with:\n          target_branch: output\n          build_dir: dist\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```\n\n<br/>\n`github_user_name` 을 수정하시고, `schedule` 을 원하는 주기대로 설정 후 커밋해주세요.  \n<br/>\n다시 Github 레포지토리로 돌아와서, **Actions** 탭에 생성된 Workflow **Generate Snake**를 확인하세요! <br/><br/>\n![github actions](https://user-images.githubusercontent.com/52748335/126319031-eba35657-dfc2-4936-9a6d-bb0da9ccc385.PNG)<br/>\n\n`Run workflow` 를 선택해 실행해줍니다.<br/><br/>\n![run](https://user-images.githubusercontent.com/52748335/126319154-b4b6a0b4-e3fc-481e-95e7-fca8939263d5.PNG)<br/>\n\nActions 탭에서 실행이 잘 된 것을 확인할 수 있습니다.<br/><br/>\n![실행 완료](https://user-images.githubusercontent.com/52748335/126319484-f92f88f6-2eaa-42a3-b1a4-d78a5b1aa945.PNG)\n\n## 3. README 수정\n\n이제 생성된 GIF 또는 SVG를 `README.md`에 추가해주는 일만 남았는데요,  \nGIF 파일은 흰색 배경이어서 Default light 테마에 어울리고, <br/>\n\n![github-contribution-grid-snake](https://user-images.githubusercontent.com/52748335/126324403-01747446-9a5d-410c-8bb5-96ca13e8a017.gif)<br/>\n\nSVG 파일은 배경이 없고 색이 조금 더 어두운 편이라 Dark high contrast 테마에 어울리는 것 같습니다. 원하는 대로 자유롭게 사용하시면 됩니다! 나중에 색상 커스텀 기능도 추가되면 좋을 것 같네요 ☺ <br/>\n![snake gif](https://raw.githubusercontent.com/6h15m/6h15m/output/github-contribution-grid-snake.svg)<br/>\n<br/>\n\n```\n![snake gif](https://github.com/[GitHub 아이디]/[GitHub 아이디]/blob/output/github-contribution-grid-snake.svg)\n```\n\n**GitHub 아이디 수정 후** 해당 코드를 README.md의 원하는 부분에 추가해 주시면 됩니다. GIF 파일로 하고 싶으시면 파일 확장자만 gif로 변경해주세요!\n<br/>\n\n![readme 추가](https://user-images.githubusercontent.com/52748335/126319766-dd6587fe-4b85-4dae-aa54-955b6525f30f.PNG)<br/>\n\n완성된 모습입니다 😊<br/>\n\n![완성](https://user-images.githubusercontent.com/52748335/126325009-491bfa72-fe43-4752-a249-93ed82bc621f.PNG)<br/>\n<br/>\n\n## 참고한 문서\n\n- [How to enable GitHub Actions on your Profile README for a snake-eating contribution graph 🐍][reference]\n\n[github-main]: https://github.com\n[facebook-posting]: https://www.facebook.com/Thomas.CS.Park/posts/10221387355058694\n[demo-site]: https://platane.github.io/snk/\n[github-snk]: https://github.com/Platane/snk\n[github-actions]: https://github.com/features/actions\n[github-actions-docs]: https://docs.github.com/en/actions/learn-github-actions\n[reference]: https://dev.to/mishmanners/how-to-enable-github-actions-on-your-profile-readme-for-a-contribution-graph-4l66?fbclid=iwar2bgcj9b_0owzs_zr5e45y1nbir-9768lyzt1y5a7e4rd4dwwrtauuliss\n"},{"fields":{"slug":"/github-blog-2/"},"frontmatter":{"date":"2021.07.05","update":"2021.07.05","title":"Github로 개발 블로그 개설하기 #2","tags":["Jekyll"],"description":"✨ 개발 블로그는 만들었지만 어떻게 꾸며야 할지 모르겠어!"},"rawMarkdownBody":"\n## 프롤로그\n\n안녕하세요! 제로입니다.  \n[저번 포스팅][github-blog-1]에서는 Github Pages를 생성해보고, Ruby와 jekyll을 설치해 블로그에 테마를 적용해보았습니다.  \n이번 포스팅에선 테마의 내용을 수정해 온전히 '내 블로그'처럼 만들어보고, 글을 작성해보고, 작성된 글에 댓글을 달아 의견을 나눌 수 있게끔 하는 방법을 알려드리려 합니다 😁\n\n## 1. jekyll 테마 사용자화\n\n![1](https://user-images.githubusercontent.com/52748335/124222304-7311d000-db3c-11eb-8db6-8b6db795d9ef.PNG)<br/>\njekyll에선 테마를 커스텀하기 위해 [\\_config.yml][jekyll-config] 파일을 제공합니다.\n프로젝트 폴더에서 \\_config.yml 파일을 찾아서 들어가봅시다.\n<br/><br/>\n![2](https://user-images.githubusercontent.com/52748335/124222692-32ff1d00-db3d-11eb-96f6-4bce5e44722a.PNG)<br/>\n\n제 테마의 경우 이렇게 내용이 들어가 있었는데요, 주석으로 어디에 어떤 내용을 넣어야 하는지 친절하게 설명되어 있습니다. <br/>\n\n```\ntitle: 영의 시간\nauthor: 6h15m\nemail: 6h15m.develop@gmail.com\ndescription: >\n  0년차 프론트엔드 개발자 성장기\nshow_excerpts: true\nsass:\n  sass_dir: _sass\nplainwhite:\n  name: 제로\n  tagline: Front-end Developer ´◡`\n  date_format: \"%b %-d, %Y\"\n  sitemap: true\n  search: true\n  dark_mode: true\n  portfolio_image: \"assets/portfolio.png\"\n  html_lang: \"ko\"\n  condensed_mobile:\n    - page\n    - post\n  social_links:\n    twitter: 20develop\n    github:  6h15m\n    facebook: 100007430927430\n    email: 6h15m.devleop@gmail.com\ntheme: plainwhite\n\nplugins:\n  - jekyll-seo-tag\n```\n\n제가 커스텀한 \\_config.xml을 참고하여 작성해보셔도 좋을 것 같습니다.\n\n## 2. 글 작성하기\n\n![3](https://user-images.githubusercontent.com/52748335/124423203-a56f3780-dd9f-11eb-972b-28984628656b.PNG)<br/>\n글은 **\\_posts**폴더에 `.md` 형태의 파일로 씁니다. 없으면 같은 이름으로 생성해주세요.  \n.md 파일의 이름은 **yyyy-mm-dd-제목** 형태여야 합니다.\n\n글에 레이아웃과 제목, 카테고리, 날짜 등을 지정하기 위해 **머릿글 생성**이 필요한데요, 제 테마는 이미 생성되어 있는 양식이 있어 내용만 교체하였습니다. 없으신 분들은 해당 테마의 readme.md를 참고하여 작성하시면 될 것 같습니다.\n\n```\n---\nlayout: post\ntitle:  \"📝 Github로 개발 블로그 개설하기 #1\"\ndate:   2021-06-28\ncategories: Blog\n---\n```\n\n글 내용을 작성하기 위해선 **마크다운 문법**을 알아야 하는데, 이 부분은 [Kim Ji-Heon 님의 정리자료][ihoneymon-markdown]와 [위키독스 마크다운 설명서][wikidocs-markdown]를 참고하시면 좋을 것 같습니다. 저도 추후에 단독 포스팅으로 정리해볼 생각이지만요!  \n~~알아두면 Github readme를 꾸밀 때 매우 유용합니다 😙~~ <br/>\n<br/>\n\n## 3. 댓글 기능 추가하기\n\n처음엔 [disqus][disqus]를 활용하여 댓글 기능을 추가해보았으나, 댓글 기록이 날아갈 수도 있고 블로그 로딩 속도가 느려진다는 글을 보아서, [utterances][utterances]로 교체해보았습니다. disqus에 비해 나은 점은 **디자인이 깔끔**하고, **Github Issue에 자동으로 저장**된다는 것이 있었습니다. 만약 댓글이 많이 달린다면 속도 차이도 체감할 수 있을 것 같네요.\n\n![7](https://user-images.githubusercontent.com/52748335/124427642-9d66c600-dda6-11eb-833f-c845aa0277c0.PNG)<br/>\nGithub apps에서 [utterances app][github-apps-utterances]을 찾아 블로그 레포지토리에 설치해줍니다.  \n설치되면 [utterances][utterances] 페이지로 이동되는데, 이곳에서 Issue title의 매핑 방식과 label, 테마 등을 커스텀할 수 있습니다. 자신이 원하는 설정으로 커스텀해줍시다.  \n저는 매핑 방식은 'Issue title contains page title', label은 설정하지 않았고 테마는 'Github Light'로 설정했습니다.\n\n```html\n<script\n  src=\"https://utteranc.es/client.js\"\n  repo=\"6h15m/6h15m.github.io\"\n  issue-term=\"title\"\n  theme=\"github-light\"\n  crossorigin=\"anonymous\"\n  async\n></script>\n```\n\n이런 식으로 커스텀되어 나온 코드를 `_layouts` 폴더의 댓글을 넣고 싶은 레이아웃 파일에 포함시켜 주면 댓글 기능이 추가됩니다.  \n저는 포스팅된 글에만 댓글 기능을 추가하고 싶어서, `post.html`에만 이렇게 추가해보았습니다.\n![8](https://user-images.githubusercontent.com/52748335/124428938-36e2a780-dda8-11eb-875b-b470a069df6c.PNG)<br/>\n\n댓글을 작성해볼까요?\n![4](https://user-images.githubusercontent.com/52748335/124429177-81fcba80-dda8-11eb-8640-2963339895b9.PNG)<br/>\n\n잘 작성되네요!\n![5](https://user-images.githubusercontent.com/52748335/124429196-8923c880-dda8-11eb-9b33-fd1217a6c7a9.PNG)<br/>\n\n이렇게 Github Issues에도 잘 추가되는 모습을 볼 수 있습니다.\n![6](https://user-images.githubusercontent.com/52748335/124429271-9f318900-dda8-11eb-8def-da8e9c172141.PNG)<br/>\n<br/>\n\n## 다음 포스팅은\n\n제가 생각해둔 내용은 모두 다룬 것 같아서 추가적인 커스텀(통계, 디자인 커스텀 등....)이 필요하다면 해볼 생각입니다. 추천하시는 커스텀 방향이 있으면 댓글로 남겨주세요!\n\n<br/>\n\n[github-blog-1]: https://6h15m.github.io/blog/2021/06/28/github-blog.html\n[jekyll-config]: https://jekyllrb.com/docs/configuration/\n[ihoneymon-markdown]: https://gist.github.com/ihoneymon/652be052a0727ad59601\n[wikidocs-markdown]: https://wikidocs.net/1678\n[disqus]: https://disqus.com/\n[utterances]: https://utteranc.es/\n[github-apps-utterances]: https://github.com/apps/utterances\n"},{"fields":{"slug":"/github-blog-1/"},"frontmatter":{"date":"2021.06.28","update":"2021.06.28","title":"Github로 개발 블로그 개설하기 #1","tags":["Jekyll"],"description":"✨ Jekyll과 Github 도메인으로 나만의 블로그를 만들어보자!"},"rawMarkdownBody":"\n## 프롤로그\n\n안녕하세요! '영의 시간' 블로그 운영자 제로입니다.  \n그동안 티스토리를 이용해 개발 블로그를 운영해오다, 자유도 높게 커스텀할 수 있다는 깃허브 블로그의 장점에 반해 새롭게 개설해보게 되었습니다.  \n첫 글에서는 Github 개발 블로그를 개설하고, 테마를 적용하는 방법을 알려드리려 합니다😊\n\n## 1. Github 블로그 사이트 만들기\n\n![1](https://user-images.githubusercontent.com/52748335/123634195-1b7e1680-d855-11eb-8024-5753975ee141.PNG)<br/>\n\n블로그 사이트를 생성하기 위해, [Github pages][github-pages] 기능을 이용해볼 것입니다.  \n해당 사진처럼 [Github][github-main]에 새 레포지토리를 생성합니다.  \nRepository name은 <b>[Github 아이디].github.io</b> 로 해주세요. 이렇게 해야 Repository name과 같은 도메인으로 접속할 수 있습니다.\n<br/><br/>\n![2](https://user-images.githubusercontent.com/52748335/123637165-ab718f80-d858-11eb-94ba-c3e21a6b3982.png)<br/>\n\n생성된 Repository의 Settings-Pages에 들어가보면 페이지가 잘 생성되었는지 확인할 수 있습니다.<br/>\n<br/>\n\n## 2. Ruby, jekyll 설치\n\n### [jekyll][jekyll-main]이란?\n\njekyll은 다양한 포맷의 텍스트 파일을 가공해서, 정적인 웹사이트로 만들어주는 Ruby 기반의 사이트 생성기입니다. markdown 문법을 지원하고, 블로그를 위한 다양한 테마가 존재하기 때문에 많이 사용되는 것 같아요. 자세한 내용을 알고 싶다면 [jekyll 문서][jekyll-docs]에 상세하게 설명되어 있으니 참고해 보세요!<br/><br/>\n\n### 설치하기\n\njekyll을 사용하기 위해 먼저 Ruby를 설치해 보겠습니다. [Ruby 다운로드 링크][ruby-downloads]를 참고하여 다운로드해 주세요. 저는 RubyInstaller [Ruby+Devkit 2.7.3-1 (x64)][ruby-download-direct] 버전을 이용하여 다운받았습니다.\n<br/><br/>\n![3](https://user-images.githubusercontent.com/52748335/123639839-892d4100-d85b-11eb-9a59-32849bfe8b73.PNG)<br/>\n\ncmd에 `ruby -v` 명령어를 입력하면 잘 설치되었는지 확인할 수 있습니다.\n<br/><br/>\n![4](https://user-images.githubusercontent.com/52748335/123641331-1f159b80-d85d-11eb-8d09-9a782d6d240f.PNG)<br/>\n\n이어서 `gem install jekyll bundler` 를 입력해 jekyll과 [bundler][jekyll-bundler-docs] [젬][jekyll-gem-docs]을 설치해줍니다.<br/>\n<br/>\n\n## 3. jekyll 테마 적용\n\n### 테마 선정\n\n- [jamstackthemes.dev][jamstackthemes-dev]\n- [jekyllthemes.org][jekyll-themes]\n- [jekyllthemes.io][jekyll-themes-io](일부 유료)<br/>\n\n이외에도 다양한 테마가 있는데, 잘 찾아본 후 가장 마음에 드는 테마를 골라주세요.\n저는 비교적 꾸준히 업데이트되고 있고, 디자인이 깔끔해보이는 [plainwhite][plainwhite] 테마를 사용하였습니다. 원래 다른 테마(persephone)을 사용하려 했는데 중국어로 구성되어 있어 알아보기 힘들었고, 현재의 테마로 교체하였습니다.\n\n### 적용하기\n\n![5](https://user-images.githubusercontent.com/52748335/123653761-6b1a0d80-d868-11eb-920a-3527031903d3.png)<br/>\n\n원하는 테마를 Clone해서, 1단계에서 만들었던 자신의 Repository에 가져옵니다. 전 ZIP 파일로 다운로드해 압축을 풀고 다시 제 프로젝트 폴더에 넣는 과정을 거쳤지만, 클론에는 다양한 방법이 있으니 다른 방법도 참고해 보시면 좋을 것 같습니다.\n<br/><br/>\n![6](https://user-images.githubusercontent.com/52748335/123654467-11fea980-d869-11eb-97c2-ea2f95b7b40b.PNG)<br/>\n\n터미널에 `bundle exec jekyll serve` 라고 입력하면 저의 경우 에러가 났습니다. 이런 경우 터미널에서 알려주는 대로 `bundle install` 을 입력하고, 다시 `bundle exec jekyll serve` 를 해주면 해결되었습니다.\n\n### 에러 발생 사례\n\n종종 본인이 세팅한 jekyll의 버전이 다운받은 테마의 jekyll 버전과 달라서 에러가 발생하기도 합니다. 그럴 땐 Gemfile.lock 파일을 삭제하고, `bundle install` 을 입력하면 다시 Gemfile.lock을 만들며 테마가 적용된 사이트의 jekyll 버전이 변경됩니다.\n\n세팅된 jekyll 버전을 바꾸고 싶다면 `gem install bundler -v [설치할 버전]` 으로 바꿀 버전을 설치해주고, `gem uninstall bundler -v [삭제할 버전]` 으로 기존 버전을 삭제해주면 됩니다.\n\n### 접속\n\n![7](https://user-images.githubusercontent.com/52748335/123655881-5e96b480-d86a-11eb-8983-4d50ee677483.PNG)<br/>\n\n잘 따라오셨다면 http://localhost:4000으로 접속했을 시, 테마의 기본적인 레이아웃이 보일 것입니다.\n\n만약 <b>index of /</b> 같은 엉뚱한 페이지가 보인다면, \\_layouts 폴더에서 main으로 사용하고 싶은 레이아웃을 가져와 프로젝트 폴더에 index.md를 만들어줘야 합니다. 예시를 보여드리겠습니다.\n\n```\n---\nlayout: home\n---\n```\n\n<br/>\n\n## 다음 포스팅은\n\njekyll 테마를 사용자화하는 방법, 글을 작성하는 방법(마크다운 문법은 다루지 않을 예정입니다)과 댓글 기능을 추가하는 방법에 대해 다룰 예정입니다.\n\n감사합니다! 😚\n\n[github-main]: https://github.com\n[github-pages]: https://pages.github.com\n[jekyll-main]: https://jekyllrb-ko.github.io/\n[jekyll-docs]: https://jekyllrb-ko.github.io/docs\n[jekyll-bundler-docs]: https://jekyllrb-ko.github.io/docs/ruby-101/#bundler\n[jekyll-gem-docs]: https://jekyllrb-ko.github.io/docs/ruby-101/#gems\n[jamstackthemes-dev]: https://jamstackthemes.dev/ssg/jekyll/\n[jekyll-themes]: http://jekyllthemes.org/\n[jekyll-themes-io]: https://jekyllthemes.io/\n[plainwhite]: https://github.com/samarsault/plainwhite-jekyll\n[ruby-downloads]: https://www.ruby-lang.org/ko/downloads/\n[ruby-download-direct]: https://github.com/oneclick/rubyinstaller2/releases/download/RubyInstaller-2.7.3-1/rubyinstaller-devkit-2.7.3-1-x64.exe\n"}]}},"pageContext":{}},
    "staticQueryHashes": ["869547123"]}